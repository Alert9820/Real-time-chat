<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Private Chat</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #e6e6e6;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: #0a0a0a;
    }
    
    .chat-header {
      padding: 12px 20px;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #2a2a2a;
    }
    
    .chat-user {
      display: flex;
      align-items: center;
    }
    
    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #3a3a3a;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
      font-weight: bold;
      color: #00af9c;
    }
    
    .header-icons {
      display: flex;
      gap: 15px;
    }
    
    .icon-btn {
      background: none;
      border: none;
      color: #a0a0a0;
      cursor: pointer;
      font-size: 18px;
    }
    
    .icon-btn:hover {
      color: #00af9c;
    }
    
    #chat {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%230d0d0d"/><path d="M0 50 L100 50 M50 0 L50 100" stroke="%231a1a1a" stroke-width="1"/></svg>');
    }
    
    .message {
      max-width: 70%;
      margin-bottom: 15px;
      position: relative;
    }
    
    .message-content {
      padding: 10px 15px;
      border-radius: 8px;
      position: relative;
    }
    
    .message.mine {
      margin-left: auto;
    }
    
    .message.mine .message-content {
      background: #005c4b;
      border-top-right-radius: 2px;
    }
    
    .message.other .message-content {
      background: #202020;
      border-top-left-radius: 2px;
    }
    
    .message-sender {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 4px;
      color: #00af9c;
    }
    
    .message-text {
      word-break: break-word;
    }
    
    .message-meta {
      text-align: right;
      font-size: 11px;
      color: #999;
      margin-top: 4px;
    }
    
    .input-container {
      padding: 15px 20px;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      border-top: 1px solid #2a2a2a;
    }
    
    .input-action {
      margin-right: 12px;
      color: #a0a0a0;
      cursor: pointer;
      font-size: 20px;
    }
    
    .input-action:hover {
      color: #00af9c;
    }
    
    #messageInput {
      flex: 1;
      background: #2d2d2d;
      border: none;
      border-radius: 20px;
      padding: 12px 18px;
      color: #e6e6e6;
      outline: none;
      font-size: 16px;
    }
    
    #sendBtn {
      margin-left: 12px;
      background: #00af9c;
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #sendBtn:hover {
      background: #008f7e;
    }
    
    .bot-indicator {
      display: inline-block;
      background: #00af9c;
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 8px;
      vertical-align: middle;
    }

    /* Message actions styles */
    .message-actions {
      position: absolute;
      top: 0;
      right: -30px;
      background: #222;
      border-radius: 4px;
      display: none;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .message:hover .message-actions {
      display: flex;
    }
    
    .action-btn {
      padding: 8px;
      cursor: pointer;
      color: #a0a0a0;
    }
    
    .action-btn:hover {
      color: #00af9c;
    }
    
    .reaction-btn {
      padding: 4px;
      font-size: 12px;
    }
    
    .message-reaction {
      margin-top: 5px;
      font-size: 12px;
      color: #00af9c;
    }
    
    .reply-indicator {
      background: rgba(0, 175, 156, 0.1);
      border-left: 3px solid #00af9c;
      padding: 8px;
      margin-bottom: 5px;
      border-radius: 4px;
      font-size: 13px;
    }
    
    .edit-mode {
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid #ffc107;
    }
    
    .typing-indicator {
      padding: 5px 15px;
      color: #999;
      font-style: italic;
      font-size: 13px;
      display: none;
    }
    
    .media-preview {
      margin-top: 10px;
      max-width: 300px;
      border-radius: 5px;
      overflow: hidden;
    }
    
    .media-preview img {
      width: 100%;
      height: auto;
      border-radius: 5px;
    }

    .bot-message {
      font-style: italic;
      color: #a0a0a0;
    }

    .system-message {
      text-align: center;
      color: #888;
      font-style: italic;
      margin: 10px 0;
    }

    .warning-message {
      text-align: center;
      color: #ff6b6b;
      font-style: italic;
      margin: 10px 0;
      background: rgba(255, 107, 107, 0.1);
      padding: 8px;
      border-radius: 8px;
    }

    .phishing-warning {
      text-align: center;
      color: #ff9c2a;
      font-style: italic;
      margin: 10px 0;
      background: rgba(255, 156, 42, 0.1);
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ff9c2a;
    }

    .locked-chat {
      background: #3a3a3a !important;
      cursor: not-allowed !important;
      opacity: 0.6;
    }

    .countdown-timer {
      color: #ff6b6b;
      font-weight: bold;
      margin-left: 10px;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div class="chat-header">
      <div class="chat-user">
        <div class="user-avatar" id="userAvatar">U</div>
        <div class="user-details">
          <div class="user-name" id="userName">User</div>
          <div class="user-status" id="userStatus">Online</div>
        </div>
      </div>
      <div class="header-icons">
        <button class="icon-btn" onclick="toggleBot()"><i class="fas fa-robot"></i></button>
        <button class="icon-btn" onclick="clearChat()"><i class="fas fa-trash"></i></button>
      </div>
    </div>
    
    <div id="chat">
      <div class="typing-indicator" id="typingIndicator"></div>
      <!-- Messages will appear here -->
    </div>
    
    <div class="input-container">
      <div class="input-action" onclick="toggleEmojiPicker()"><i class="far fa-smile"></i></div>
      <div class="input-action" onclick="document.getElementById('fileInput').click()">
        <i class="fas fa-paperclip"></i>
        <input type="file" id="fileInput" style="display: none;" onchange="handleFileSelect(event)" accept="image/*">
      </div>
      <input type="text" id="messageInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)" oninput="handleTyping()">
      <button id="sendBtn"><i class="fas fa-paper-plane"></i></button>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
<script>
    // ‚úÖ Get current user
    const currentUser = JSON.parse(localStorage.getItem("user"));
    if (!currentUser || !currentUser.uid || !currentUser.name) {
        alert("‚ùå User not logged in. Redirecting...");
        window.location.href = "login.html";
    }

    // ‚úÖ Set user info in UI
    document.getElementById('userName').textContent = currentUser.name;
    document.getElementById('userAvatar').textContent = currentUser.name.charAt(0).toUpperCase();

    // ‚úÖ Friend UID
    const params = new URLSearchParams(window.location.search);
    const friendUid = params.get("uid");
    if (!friendUid) {
        alert("‚ùå Friend UID missing in URL!");
        throw new Error("Friend UID missing");
    }

    const room = [currentUser.uid, friendUid].sort().join("_");

    // ‚úÖ IMPROVED: Advanced Phishing Check Function
    async function checkPhishing(text) {
        try {
            // First check for common phishing patterns locally (fast)
            const phishingPatterns = [
                /(?:https?:\/\/)?(?:www\.)?([a-zA-Z0-9-]+)\.(?:login|verify|secure|account|update|confirm)/gi,
                /bit\.ly|tinyurl|goo\.gl|t\.co|shorte\.st|adf\.ly|bitly\.com/gi,
                /(urgent|immediately|verify.*account|password.*expire|security.*alert)/gi,
                /free.*money|win.*prize|click.*here|limited.*time/gi,
                /bank.*details|credit.*card|password.*reset|account.*recovery/gi
            ];
            
            for (const pattern of phishingPatterns) {
                if (pattern.test(text)) {
                    console.log("üõ°Ô∏è Local phishing pattern detected");
                    return true;
                }
            }

            // Check for suspicious URLs
            const urlRegex = /https?:\/\/[^\s]+/g;
            const urls = text.match(urlRegex);
            if (urls) {
                const suspiciousDomains = ['login', 'verify', 'secure', 'account', 'bank', 'paypal'];
                const isSuspicious = urls.some(url => 
                    suspiciousDomains.some(domain => url.toLowerCase().includes(domain))
                );
                if (isSuspicious) {
                    console.log("üõ°Ô∏è Suspicious URL detected");
                    return true;
                }
            }

            // Then use API for advanced detection
            const response = await fetch('/check-phishing', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            console.log("üõ°Ô∏è Phishing API response:", data);
            
            // Handle multiple response formats
            if (data.isPhishing !== undefined) {
                return data.isPhishing;
            }
            
            if (Array.isArray(data) && data.length > 0) {
                const firstItem = data[0];
                
                if (Array.isArray(firstItem)) {
                    const phishingData = firstItem.find(item => item.label && 
                        (item.label.toLowerCase().includes('phishing') || item.label.toLowerCase().includes('malicious')));
                    return phishingData ? phishingData.score > 0.6 : false;
                }
                
                if (firstItem.label && firstItem.score) {
                    const isPhishing = firstItem.label.toLowerCase().includes('phishing') || 
                                      firstItem.label.toLowerCase().includes('malicious');
                    return isPhishing && firstItem.score > 0.6;
                }
            }
            
            if (data.label && data.score) {
                const isPhishing = data.label.toLowerCase().includes('phishing') || 
                                  data.label.toLowerCase().includes('malicious');
                return isPhishing && data.score > 0.6;
            }
            
            return false;
        } catch (error) {
            console.error("üõ°Ô∏è Phishing check error:", error);
            // Fallback: basic pattern matching
            const fallbackPatterns = [
                /login.*required|verify.*now|security.*breach/gi,
                /claim.*reward|free.*gift|won.*prize/gi
            ];
            return fallbackPatterns.some(pattern => pattern.test(text));
        }
    }

    // ‚úÖ IMPROVED: Enhanced Toxicity Check Function
    async function checkToxicity(message) {
        try {
            // First check for common toxic words locally (fast)
            const toxicWords = [
                // English
                'fuck', 'shit', 'bitch', 'asshole', 'dick', 'pussy', 'bastard', 'whore', 'cunt',
                'motherfucker', 'bullshit', 'damn', 'hell', 'douche', 'retard', 'faggot',
                
                // Hindi
                'madarchod', 'bhenchod', 'chutiya', 'lund', 'gaand', 'maa ki', 'behen ki', 
                'kutta', 'kamina', 'harami', 'gandu', 'bhosdi', 'chod', 'lavde', 'randi',
                'kuttiya', 'saala', 'suar', 'kamine', 'bewakoof'
            ];
            
            const lowerMessage = message.toLowerCase();
            const foundToxicWord = toxicWords.some(word => lowerMessage.includes(word.toLowerCase()));
            if (foundToxicWord) {
                console.log("üö´ Local toxic word detected");
                return true;
            }

            // Then use API for advanced detection
            const response = await fetch('/check-toxicity', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message })
            });
            
            if (!response.ok) {
                throw new Error('Toxicity API error');
            }
            
            const result = await response.json();
            console.log("üö´ Toxicity API result:", result);
            
            // Dynamic threshold based on warning count
            const warnings = getWarnings();
            const dynamicThreshold = 0.7 - (warnings * 0.08); // Gets stricter with more warnings
            const finalThreshold = Math.max(dynamicThreshold, 0.3); // Minimum 30%
            
            return result.isToxic || (result.score > finalThreshold);
            
        } catch (error) {
            console.error("üö´ Toxicity check error:", error);
            // Fallback to basic word check
            const basicToxicWords = ['madarchod', 'bhenchod', 'chutiya', 'fuck', 'shit', 'bitch'];
            return basicToxicWords.some(word => message.toLowerCase().includes(word));
        }
    }

    // ‚úÖ IMPROVED: Advanced Warning System with Progressive Lock Times
    function getWarnings() {
        const warningData = JSON.parse(localStorage.getItem(`${room}_warning_data`)) || { count: 0, lockLevel: 0 };
        return warningData.count;
    }

    function getLockLevel() {
        const warningData = JSON.parse(localStorage.getItem(`${room}_warning_data`)) || { count: 0, lockLevel: 0 };
        return warningData.lockLevel;
    }

    function setWarningData(count, lockLevel) {
        const warningData = { count, lockLevel, timestamp: Date.now(), userId: currentUser.uid };
        localStorage.setItem(`${room}_warning_data`, JSON.stringify(warningData));
        updateWarningDisplay();
    }

    function addWarning() {
        const warningData = JSON.parse(localStorage.getItem(`${room}_warning_data`)) || { count: 0, lockLevel: 0 };
        warningData.count += 1;
        
        // Increase lock level every 5 warnings
        if (warningData.count % 5 === 0) {
            warningData.lockLevel += 1;
        }
        
        setWarningData(warningData.count, warningData.lockLevel);
        
        // Start chat lock if warnings reach threshold
        if (warningData.count >= 5) {
            startChatLock(warningData.lockLevel);
        }
        
        return warningData.count;
    }

    function resetWarnings() {
        // Only reset count, preserve lock level for persistence
        const warningData = JSON.parse(localStorage.getItem(`${room}_warning_data`)) || { count: 0, lockLevel: 0 };
        setWarningData(0, warningData.lockLevel);
        clearChatLock();
    }

    // ‚úÖ IMPROVED: Progressive Lock System
    function getLockTimes() {
        return [30, 60, 120, 300, 600]; // 30s, 1m, 2m, 5m, 10m
    }

    function getLockTime() {
        const lockData = JSON.parse(localStorage.getItem(`${room}_lock_data`)) || { unlockTime: 0, lockLevel: 0 };
        return lockData.unlockTime;
    }

    function setLockTime(unlockTime, lockLevel) {
        const lockData = { unlockTime, lockLevel, userId: currentUser.uid };
        localStorage.setItem(`${room}_lock_data`, JSON.stringify(lockData));
    }

    function clearChatLock() {
        localStorage.removeItem(`${room}_lock_data`);
        updateWarningDisplay();
    }

    function isChatLocked() {
        const lockData = JSON.parse(localStorage.getItem(`${room}_lock_data`)) || { unlockTime: 0 };
        if (!lockData.unlockTime) return false;
        
        return Date.now() < lockData.unlockTime;
    }

    function startChatLock(lockLevel = 0) {
        const lockTimes = getLockTimes();
        const lockDuration = lockTimes[Math.min(lockLevel, lockTimes.length - 1)] * 1000; // Convert to milliseconds
        const unlockTime = Date.now() + lockDuration;
        
        setLockTime(unlockTime, lockLevel);
        updateWarningDisplay();
        
        // Start countdown timer
        startLockCountdown();
        
        // Notify user
        const lockMinutes = Math.ceil(lockDuration / 1000 / 60);
        addWarningMessage(`üîí Chat locked for ${lockMinutes} minute(s) due to multiple violations!`);
    }

    function startLockCountdown() {
        // Clear any existing interval
        if (window.lockCountdownInterval) {
            clearInterval(window.lockCountdownInterval);
        }
        
        window.lockCountdownInterval = setInterval(() => {
            const lockData = JSON.parse(localStorage.getItem(`${room}_lock_data`)) || { unlockTime: 0 };
            if (!lockData.unlockTime) {
                clearInterval(window.lockCountdownInterval);
                return;
            }
            
            const timeRemaining = lockData.unlockTime - Date.now();
            
            if (timeRemaining <= 0) {
                clearInterval(window.lockCountdownInterval);
                clearChatLock();
                addSystemMessage("‚úÖ Chat unlocked. You can message now.");
                return;
            }
            
            updateCountdownDisplay(Math.ceil(timeRemaining / 1000));
        }, 1000);
    }

    function updateCountdownDisplay(seconds) {
        const statusElement = document.getElementById('userStatus');
        if (statusElement) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            statusElement.innerHTML = `Locked: <span class="countdown-timer">${minutes}:${remainingSeconds.toString().padStart(2, '0')}</span>`;
        }
    }

    function updateWarningDisplay() {
        const warnings = getWarnings();
        const lockLevel = getLockLevel();
        const statusElement = document.getElementById('userStatus');
        
        if (isChatLocked()) {
            const lockData = JSON.parse(localStorage.getItem(`${room}_lock_data`)) || { unlockTime: 0 };
            const timeRemaining = Math.ceil((lockData.unlockTime - Date.now()) / 1000);
            
            document.getElementById("messageInput").disabled = true;
            document.getElementById("messageInput").classList.add('locked-chat');
            document.getElementById("messageInput").placeholder = `Chat locked (Level ${lockLevel + 1})`;
            document.getElementById("sendBtn").disabled = true;
            
            if (statusElement) {
                const minutes = Math.floor(timeRemaining / 60);
                const seconds = timeRemaining % 60;
                statusElement.innerHTML = `Locked L${lockLevel + 1}: <span class="countdown-timer">${minutes}:${seconds.toString().padStart(2, '0')}</span>`;
                statusElement.style.color = '#ff6b6b';
            }
        } else {
            document.getElementById("messageInput").disabled = false;
            document.getElementById("messageInput").classList.remove('locked-chat');
            document.getElementById("messageInput").placeholder = "Type a message...";
            document.getElementById("sendBtn").disabled = false;
            
            if (statusElement) {
                statusElement.textContent = warnings > 0 ? `Online (Warnings: ${warnings}, Level: ${lockLevel + 1})` : 'Online';
                statusElement.style.color = warnings >= 5 ? '#ffa726' : '';
            }
        }
    }

    // ‚úÖ IMPROVED: Clear Chat without resetting warnings
    function clearChat() {
        if (confirm("Clear all messages in this chat? (Warning: This will not reset your warning count)")) {
            fetch('/clear-room', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ room })
            })
            .then(response => response.text())
            .then(result => {
                document.getElementById("chat").innerHTML = '<div class="typing-indicator" id="typingIndicator"></div>';
                
                // Preserve lock status
                if (isChatLocked()) {
                    const lockData = JSON.parse(localStorage.getItem(`${room}_lock_data`)) || { unlockTime: 0 };
                    const timeRemaining = Math.ceil((lockData.unlockTime - Date.now()) / 1000);
                    addSystemMessage(`Chat cleared. Lock remains active for ${timeRemaining} seconds.`);
                } else {
                    addSystemMessage("Chat cleared successfully");
                }
            })
            .catch(error => console.error('Error clearing chat:', error));
        }
    }

    // ‚úÖ Initialize on page load
    function initializeChat() {
        // Check for existing lock status
        const lockData = JSON.parse(localStorage.getItem(`${room}_lock_data`)) || { unlockTime: 0 };
        const warningData = JSON.parse(localStorage.getItem(`${room}_warning_data`)) || { count: 0, lockLevel: 0 };
        
        // Verify data belongs to current user
        if (lockData.userId !== currentUser.uid) {
            localStorage.removeItem(`${room}_lock_data`);
            localStorage.removeItem(`${room}_warning_data`);
        } else if (isChatLocked()) {
            startLockCountdown();
        }
        
        updateWarningDisplay();
    }

    // ‚úÖ Socket setup
    const socket = io();
    let isSending = false;
    let botActive = false;
    let isEditing = false;
    let editingMessageId = null;
    let replyToMessageId = null;

    socket.on("connect", () => {
        console.log("Connected:", socket.id);
        socket.emit("set_name", { uid: currentUser.uid, name: currentUser.name });
        socket.emit("join-room", room);

        // Initialize chat system
        initializeChat();

        // Load previous messages
        fetch(`/get-room-messages?room=${room}`)
            .then(res => res.json())
            .then(msgs => msgs.forEach(m => {
                if (!m.text.includes('__signal')) {
                    addMessage(m.sender, m.text, m.sender === currentUser.name, m.sender === 'BotX');
                }
            }))
            .catch(err => console.error("Failed to load messages:", err));
    });

    // ... (rest of your socket event handlers remain the same)
    socket.on("private-message", data => {
        if (!data.text.includes('__signal')) {
            addMessage(data.sender, data.text, data.sender === currentUser.name);
        }
    });
    
    socket.on("bot-reply", data => {
        addMessage(data.sender, data.text, false, true);
    });

    socket.on("image-message", data => {
        if (data.room === room) {
            addImageMessage(data.sender, data.imageData, data.sender === currentUser.name);
        }
    });

    socket.on("typing", (data) => {
        if (data.room === room && data.sender !== currentUser.name) {
            const indicator = document.getElementById('typingIndicator');
            indicator.textContent = `${data.sender} is typing...`;
            indicator.style.display = 'block';
            
            clearTimeout(window.typingTimeout);
            window.typingTimeout = setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
        }
    });

    socket.on("message", (data) => {
        if (data.sender === "System" && data.text.includes("Bot")) {
            addSystemMessage(data.text);
        }
    });

    // ‚úÖ IMPROVED: Send message function
    async function sendMessage() {
        if (isSending) return;
        
        const text = document.getElementById("messageInput").value.trim();
        if (!text) return;

        // Chat locked check
        if (isChatLocked()) {
            const lockData = JSON.parse(localStorage.getItem(`${room}_lock_data`)) || { unlockTime: 0 };
            const timeRemaining = Math.ceil((lockData.unlockTime - Date.now()) / 1000);
            addWarningMessage(`üîí Chat locked! Please wait ${timeRemaining} seconds.`);
            document.getElementById("messageInput").value = "";
            return;
        }

        // Skip checks for bot commands
        if (text === ">>bot" || text === "<<bot") {
            isSending = true;
            socket.emit("message", text);
            document.getElementById("messageInput").value = "";
            isSending = false;
            return;
        }

        // Check for phishing first
        const isPhishing = await checkPhishing(text);
        if (isPhishing) {
            addPhishingWarning(text);
            document.getElementById("messageInput").value = "";
            return;
        }

        // Then check for toxicity
        const isToxic = await checkToxicity(text);
        if (isToxic) {
            const warnings = addWarning();
            const lockLevel = getLockLevel();
            addWarningMessage(`‚ö†Ô∏è Warning ${warnings}/5 (Level ${lockLevel + 1}): Toxic content detected!`);
            
            if (warnings >= 5) {
                const lockTimes = getLockTimes();
                const lockDuration = lockTimes[Math.min(lockLevel, lockTimes.length - 1)];
                addWarningMessage(`üîí Chat locked for ${lockDuration} seconds due to multiple violations!`);
            }
            
            document.getElementById("messageInput").value = "";
            return;
        }

        // If all checks pass, send the message
        isSending = true;
        
        const payload = { room, sender: currentUser.name, text };
        socket.emit("private-message", payload);
        
        document.getElementById("messageInput").value = "";
        
        // Reset edit and reply modes
        if (isEditing) {
            isEditing = false;
            editingMessageId = null;
            document.getElementById('messageInput').placeholder = "Type a message...";
            document.getElementById('messageInput').classList.remove('edit-mode');
        }
        
        if (replyToMessageId) {
            replyToMessageId = null;
        }
        
        setTimeout(() => { isSending = false; }, 300);
    }

    // ... (rest of your functions remain the same)
    function addPhishingWarning(originalText) {
        const warningMessage = `üö´ Phishing link detected! Message blocked: "${truncateText(originalText, 50)}"`;
        addPhishingMessage(warningMessage);
        
        const phishingPayload = {
            room,
            sender: "System",
            text: `‚ö†Ô∏è ${currentUser.name} tried to send a phishing link (automatically blocked)`
        };
        socket.emit("private-message", phishingPayload);
    }

    function truncateText(text, maxLength) {
        return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
    }

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initializeChat();
        document.getElementById("sendBtn").addEventListener("click", sendMessage);
        document.getElementById("messageInput").addEventListener("keypress", e => { 
            if (e.key === "Enter") sendMessage(); 
        });
    });
</script>
</body>
</html>
